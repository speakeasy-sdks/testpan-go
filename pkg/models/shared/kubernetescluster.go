// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy-sdks/testpan-go/pkg/utils"
)

type KubernetesClusterOrchestrationType string

const (
	KubernetesClusterOrchestrationTypeGke        KubernetesClusterOrchestrationType = "GKE"
	KubernetesClusterOrchestrationTypeOpenshift  KubernetesClusterOrchestrationType = "OPENSHIFT"
	KubernetesClusterOrchestrationTypeRancher    KubernetesClusterOrchestrationType = "RANCHER"
	KubernetesClusterOrchestrationTypeAks        KubernetesClusterOrchestrationType = "AKS"
	KubernetesClusterOrchestrationTypeEks        KubernetesClusterOrchestrationType = "EKS"
	KubernetesClusterOrchestrationTypeKubernetes KubernetesClusterOrchestrationType = "KUBERNETES"
	KubernetesClusterOrchestrationTypeIks        KubernetesClusterOrchestrationType = "IKS"
)

func (e KubernetesClusterOrchestrationType) ToPointer() *KubernetesClusterOrchestrationType {
	return &e
}

func (e *KubernetesClusterOrchestrationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "GKE":
		fallthrough
	case "OPENSHIFT":
		fallthrough
	case "RANCHER":
		fallthrough
	case "AKS":
		fallthrough
	case "EKS":
		fallthrough
	case "KUBERNETES":
		fallthrough
	case "IKS":
		*e = KubernetesClusterOrchestrationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for KubernetesClusterOrchestrationType: %v", v)
	}
}

type KubernetesCluster struct {
	AccountName *string `json:"accountName,omitempty"`
	// indicates fail close behavior on Secure Application agent failure
	AgentFailClose *bool `default:"false" json:"agentFailClose"`
	// indicates whether apiIntelligenceDAST is enabled
	APIIntelligenceDAST *bool `default:"false" json:"apiIntelligenceDAST"`
	// indicates whether auto label is enabled
	AutoLabelEnabled *bool `default:"false" json:"autoLabelEnabled"`
	// indicates whether upgrade the controller automatically
	AutoUpgradeControllerVersion *bool `default:"true" json:"autoUpgradeControllerVersion"`
	// indicates whether deployer is required for the automated policy
	AutomatedPolicyRequiresDeployer *bool `default:"false" json:"automatedPolicyRequiresDeployer"`
	// Enable pod template images signature validation
	CiImageSignatureValidation *bool `default:"false" json:"ciImageSignatureValidation"`
	// Enable pod template images validation
	CiImageValidation *bool `default:"false" json:"ciImageValidation"`
	// The source type of the pod definitions of the cluster
	ClusterPodDefinitionSource *ClusterPodDefinitionSource `default:"KUBERNETES" json:"clusterPodDefinitionSource"`
	ControllerDataResponse     *ControllerDataResponse     `json:"controllerDataResponse,omitempty"`
	// The current controller state.
	ControllerStatus *ControllerStatus `json:"controllerStatus,omitempty"`
	// indicates whether Secure Application allows connections actions and detections
	EnableConnectionsControl *bool                     `default:"false" json:"enableConnectionsControl"`
	HelmCommandsInstallation *HelmCommandsInstallation `json:"helmCommandsInstallation,omitempty"`
	// Id of the cluster.
	ID *string `json:"id,omitempty"`
	// indicates whether envoy/istio will be used as a trace source
	InstallEnvoyTracingSupport *bool `default:"false" json:"installEnvoyTracingSupport"`
	// indicates whether to install tracing support, enable for apiSecurity accounts
	InstallTracingSupport *bool               `default:"false" json:"installTracingSupport"`
	InstallationSource    *InstallationSource `default:"SCRIPT" json:"installationSource"`
	// internal registry information
	InternalRegistryParameters *InternalRegistryParameters `json:"internalRegistryParameters,omitempty"`
	// indicates whether the controller should hold the application until the proxy starts
	IsHoldApplicationUntilProxyStarts *bool `default:"false" json:"isHoldApplicationUntilProxyStarts"`
	// indicates whether Istio ingress is enabled
	IsIstioIngressEnabled *bool `default:"false" json:"isIstioIngressEnabled"`
	// indicates whether this cluster should support multi-cluster communication
	IsMultiCluster *bool `default:"false" json:"isMultiCluster"`
	// indicates whether the agent should run in persistent mode
	IsPersistent *bool `default:"false" json:"isPersistent"`
	// annotations for load balancers
	IstioIngressAnnotations []KubernetesAnnotation `json:"istioIngressAnnotations,omitempty"`
	// istio related information
	IstioInstallationParameters *IstioInstallationParameters `json:"istioInstallationParameters,omitempty"`
	// indicates whether kubernetes events sending is enabled
	K8sEventsEnabled *bool `default:"false" json:"k8sEventsEnabled"`
	// indicates whether kubernetes security is enabled
	KubernetesSecurity                *bool                               `default:"false" json:"kubernetesSecurity"`
	MinimalNumberOfControllerReplicas *int64                              `json:"minimalNumberOfControllerReplicas,omitempty"`
	Name                              string                              `json:"name"`
	OrchestrationType                 *KubernetesClusterOrchestrationType `default:"GKE" json:"orchestrationType"`
	// indicates whether the agent should preserve the original source ip
	PreserveOriginalSourceIP *bool               `default:"false" json:"preserveOriginalSourceIp"`
	ProxyConfiguration       *ProxyConfiguration `json:"proxyConfiguration,omitempty"`
	// indicates whether the agent validate the images origin
	RestrictRegistires *bool `default:"false" json:"restrictRegistires"`
	// scan configuration information
	ScanConfiguration *ScanConfiguration `json:"scanConfiguration,omitempty"`
	// indicates whether the service discovery isolation is enabled
	ServiceDiscoveryIsolationEnabled *bool             `default:"false" json:"serviceDiscoveryIsolationEnabled"`
	SidecarsResources                *SidecarsResource `json:"sidecarsResources,omitempty"`
	// indicates whether SSH monitoring is disabled
	SSHMonitorDisabled *bool `default:"true" json:"sshMonitorDisabled"`
	// indicates whether external trace sources are supported
	SupportExternalTraceSource *bool `default:"false" json:"supportExternalTraceSource"`
	// indicates whether TLS inspection is enabled
	TLSInspectionEnabled *bool `default:"false" json:"tlsInspectionEnabled"`
	// indicates whether token injection is enabled
	TokenInjectionEnabled *bool `default:"false" json:"tokenInjectionEnabled"`
	// indicates whether kubernetes should use external CA
	UseExternalCA *bool `default:"false" json:"useExternalCA"`
}

func (k KubernetesCluster) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KubernetesCluster) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *KubernetesCluster) GetAccountName() *string {
	if o == nil {
		return nil
	}
	return o.AccountName
}

func (o *KubernetesCluster) GetAgentFailClose() *bool {
	if o == nil {
		return nil
	}
	return o.AgentFailClose
}

func (o *KubernetesCluster) GetAPIIntelligenceDAST() *bool {
	if o == nil {
		return nil
	}
	return o.APIIntelligenceDAST
}

func (o *KubernetesCluster) GetAutoLabelEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.AutoLabelEnabled
}

func (o *KubernetesCluster) GetAutoUpgradeControllerVersion() *bool {
	if o == nil {
		return nil
	}
	return o.AutoUpgradeControllerVersion
}

func (o *KubernetesCluster) GetAutomatedPolicyRequiresDeployer() *bool {
	if o == nil {
		return nil
	}
	return o.AutomatedPolicyRequiresDeployer
}

func (o *KubernetesCluster) GetCiImageSignatureValidation() *bool {
	if o == nil {
		return nil
	}
	return o.CiImageSignatureValidation
}

func (o *KubernetesCluster) GetCiImageValidation() *bool {
	if o == nil {
		return nil
	}
	return o.CiImageValidation
}

func (o *KubernetesCluster) GetClusterPodDefinitionSource() *ClusterPodDefinitionSource {
	if o == nil {
		return nil
	}
	return o.ClusterPodDefinitionSource
}

func (o *KubernetesCluster) GetControllerDataResponse() *ControllerDataResponse {
	if o == nil {
		return nil
	}
	return o.ControllerDataResponse
}

func (o *KubernetesCluster) GetControllerStatus() *ControllerStatus {
	if o == nil {
		return nil
	}
	return o.ControllerStatus
}

func (o *KubernetesCluster) GetEnableConnectionsControl() *bool {
	if o == nil {
		return nil
	}
	return o.EnableConnectionsControl
}

func (o *KubernetesCluster) GetHelmCommandsInstallation() *HelmCommandsInstallation {
	if o == nil {
		return nil
	}
	return o.HelmCommandsInstallation
}

func (o *KubernetesCluster) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *KubernetesCluster) GetInstallEnvoyTracingSupport() *bool {
	if o == nil {
		return nil
	}
	return o.InstallEnvoyTracingSupport
}

func (o *KubernetesCluster) GetInstallTracingSupport() *bool {
	if o == nil {
		return nil
	}
	return o.InstallTracingSupport
}

func (o *KubernetesCluster) GetInstallationSource() *InstallationSource {
	if o == nil {
		return nil
	}
	return o.InstallationSource
}

func (o *KubernetesCluster) GetInternalRegistryParameters() *InternalRegistryParameters {
	if o == nil {
		return nil
	}
	return o.InternalRegistryParameters
}

func (o *KubernetesCluster) GetIsHoldApplicationUntilProxyStarts() *bool {
	if o == nil {
		return nil
	}
	return o.IsHoldApplicationUntilProxyStarts
}

func (o *KubernetesCluster) GetIsIstioIngressEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.IsIstioIngressEnabled
}

func (o *KubernetesCluster) GetIsMultiCluster() *bool {
	if o == nil {
		return nil
	}
	return o.IsMultiCluster
}

func (o *KubernetesCluster) GetIsPersistent() *bool {
	if o == nil {
		return nil
	}
	return o.IsPersistent
}

func (o *KubernetesCluster) GetIstioIngressAnnotations() []KubernetesAnnotation {
	if o == nil {
		return nil
	}
	return o.IstioIngressAnnotations
}

func (o *KubernetesCluster) GetIstioInstallationParameters() *IstioInstallationParameters {
	if o == nil {
		return nil
	}
	return o.IstioInstallationParameters
}

func (o *KubernetesCluster) GetK8sEventsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.K8sEventsEnabled
}

func (o *KubernetesCluster) GetKubernetesSecurity() *bool {
	if o == nil {
		return nil
	}
	return o.KubernetesSecurity
}

func (o *KubernetesCluster) GetMinimalNumberOfControllerReplicas() *int64 {
	if o == nil {
		return nil
	}
	return o.MinimalNumberOfControllerReplicas
}

func (o *KubernetesCluster) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *KubernetesCluster) GetOrchestrationType() *KubernetesClusterOrchestrationType {
	if o == nil {
		return nil
	}
	return o.OrchestrationType
}

func (o *KubernetesCluster) GetPreserveOriginalSourceIP() *bool {
	if o == nil {
		return nil
	}
	return o.PreserveOriginalSourceIP
}

func (o *KubernetesCluster) GetProxyConfiguration() *ProxyConfiguration {
	if o == nil {
		return nil
	}
	return o.ProxyConfiguration
}

func (o *KubernetesCluster) GetRestrictRegistires() *bool {
	if o == nil {
		return nil
	}
	return o.RestrictRegistires
}

func (o *KubernetesCluster) GetScanConfiguration() *ScanConfiguration {
	if o == nil {
		return nil
	}
	return o.ScanConfiguration
}

func (o *KubernetesCluster) GetServiceDiscoveryIsolationEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ServiceDiscoveryIsolationEnabled
}

func (o *KubernetesCluster) GetSidecarsResources() *SidecarsResource {
	if o == nil {
		return nil
	}
	return o.SidecarsResources
}

func (o *KubernetesCluster) GetSSHMonitorDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.SSHMonitorDisabled
}

func (o *KubernetesCluster) GetSupportExternalTraceSource() *bool {
	if o == nil {
		return nil
	}
	return o.SupportExternalTraceSource
}

func (o *KubernetesCluster) GetTLSInspectionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.TLSInspectionEnabled
}

func (o *KubernetesCluster) GetTokenInjectionEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.TokenInjectionEnabled
}

func (o *KubernetesCluster) GetUseExternalCA() *bool {
	if o == nil {
		return nil
	}
	return o.UseExternalCA
}
